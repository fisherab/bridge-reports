#!/usr/bin/env python3

import csv

from jinja2 import Template, FileSystemLoader, TemplateNotFound, Environment, select_autoescape
from os.path import join, exists, getmtime
import sys
from pathlib import Path
from datetime import date, datetime

# Parse the arguments
args = (sys.argv[1:])
if len(args) != 2:
    sys.exit("Must have two arguments .. the event file and the event title")
resultsFile, title = args

# Fill the results dictionary with boards from the csv file. It is indexed by boardnum and contains a list of boards
# Fill the resultsByPair dictionary indexed by pair number with a dictionary of boards indexed by boardnumber
# Keynames is an array with the keys found in the csv file header
# Pairs is a dictionary indexed by pair number and holding the pair names and ns is a set of NS pair numbers
with open(resultsFile) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=',')
    keynames = [] 
    results = {}
    resultsByPair = {}
    pairs = {}
    ns = set()
    wantedKeys = ['board', 'score', 'ns_pair', 'ew_pair', 'north_username', 'south_username', 'east_username', 'west_username']

    for row in csv_reader:
        if not keynames:
            keynames = row
        else:
            board = {}
            for keyname, value in zip(keynames, row):
                if keyname in wantedKeys:
                    board[keyname] = value;
            boardNum = int(board['board'])
            board['score'] = int(board['score'])
            if boardNum not in results: results[boardNum] = []
            results[boardNum].append(board)
            nspair = board['ns_pair']
            ewpair = board['ew_pair']
            pairs[nspair] = board['north_username'],board['south_username']
            pairs[ewpair] = board['east_username'],board['west_username']
            ns.add(nspair)
            for dirn in ['north', 'south', 'east', 'west']: del board[dirn + '_username']
            if nspair not in resultsByPair:
                resultsByPair[nspair] = {boardNum:board}
            else:
                resultsByPair[nspair][boardNum] = board   
            if ewpair not in resultsByPair:
                resultsByPair[ewpair] = {boardNum:board}
            else:
                resultsByPair[ewpair][boardNum] = board   

# For each board number sort the boards by score and calculate the points and percentages
for boardNum in results:
    played = len(results[boardNum])
    results[boardNum].sort(key=lambda board: board['score'],reverse=True)

for key in results.keys():
    resultsForBoard = results[key]
    index = 0
    best = resultsForBoard[index]['score']
    for seqnum in range(len(resultsForBoard)):
        board = resultsForBoard[seqnum]
        if resultsForBoard[seqnum]['score'] < best:
            for i in range(index, seqnum):
                resultsForBoard[i]['ns_points'] = 2*played - index-seqnum-1
                resultsForBoard[i]['ew_points'] = 2*played - 2 - resultsForBoard[i]['ns_points']
            index = seqnum
            best = resultsForBoard[index]['score']

    for i in range(index, len(resultsForBoard)):
        resultsForBoard[i]['ns_points'] = 2*played - index-len(resultsForBoard)-1
        resultsForBoard[i]['ew_points'] = 2*played - 2 - resultsForBoard[i]['ns_points']

    for board in resultsForBoard:
        board["ns_%"] = round(board['ns_points'] * 50 / (len(resultsForBoard)-1),2)
        board["ew_%"] = round(board['ew_points'] * 50 / (len(resultsForBoard)-1),2)

# Fill the rankings dictionary indexed by pair number and compute the total points for each pair
rankings = {}
for i in range(len(pairs)):
    rankings[str(i+1)] = {'points':0} 

for key in results.keys():
    resultsForBoard = results[key]
    for board in resultsForBoard:
        rankings[board['ns_pair']]['points'] +=  board['ns_points']
        rankings[board['ew_pair']]['points'] +=  board['ew_points']

# Compute the ranking table which is a list of rankings and include percentages and other quantities
rankingTable = []
tops = len(results) * (2* played -2)
for key in rankings.keys():
    ranking = rankings[key]
    ranking['%'] = ranking['points'] * 100. / tops
    ranking['pair'] = key
    ranking['name'] = pairs[key]
    ranking['tops'] = tops
    rankingTable.append(ranking)

# Sort the ranking list by percentage score. As all play the same number of boards 
# we could have used points.
rankingTable.sort(key = lambda pair: pair['%'], reverse=True)

# Build separe rankings for NS and for EW
rankingTableNS = []
rankingTableEW = []
for ranking in rankingTable:
    if ranking['pair'] in ns:
        rankingTableNS.append(ranking)
    else:
        rankingTableEW.append(ranking)

# Compute the position making sure that identical percenatges are handled correctly and then 
# round the percentages
for rankingTable in rankingTableNS,rankingTableEW:
    pos = 0
    oldScore = rankingTable[0]["%"]
    for i in range (len(rankingTable)):
        ranking =  rankingTable[i]            
        if ranking["%"] != oldScore:
            scoreText = str(pos+1)
            if i != pos + 1: scoreText += "="
            for j in range(pos,i):
                rankingTable[j]["pos"] = scoreText
            oldScore = ranking["%"]
            pos = i
    scoreText = str(pos+1)
    if len(rankingTable) != pos + 1: scoreText += "="
    for j in range(pos,len(rankingTable)):
        rankingTable[j]["pos"] = scoreText

    for ranking in rankingTable:
        ranking["%"] = round(ranking['%'],2)

# Build a list of board results for each pair
boardsByPair = []
for pair in pairs:
    for i in range(len(results)):
        pass


env = Environment(
loader=FileSystemLoader('.'),
autoescape=select_autoescape(['html'])
)

p = Path('.')/"events"
if p.exists():
    with open("events") as eventfile:
        events = eventfile.readlines()
else:
    events = []
eventNum = len(events)
now = datetime.now()
fullTitle = str(now.day) + '/' + str(now.month) + '/' + str(now.year) + ' ' + title + ' (' + str(len(pairs)/2) + ' pairs)'

# Write the events file back
desc = str(eventNum) + ' ' + fullTitle
nl = p.exists()
with open(p,"a") as eventfile:
    if nl: eventfile.write('\n')
    eventfile.write(desc)
events.append(desc)

z = Path('.')/"sd"
ev = z/str(eventNum)
ev.mkdir(parents = True, exist_ok = True)
template = env.get_template('ranking.html')
with open(ev/"ranking.html",'w') as evfile:
    print(template.render(title=fullTitle, rankingNS=rankingTableNS, rankingEW=rankingTableEW),file=evfile)
events.reverse()
with open(z/"index.html",'w') as eventsListFile:
    print(env.get_template('events.html').render(events = events), file = eventsListFile)
